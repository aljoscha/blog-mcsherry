# Recursion in Materialize

[Materialize]() is a SQL database that uses [Differential Dataflow]() for its computational layer.
When Differential Dataflow got invented, it introduced one fundamental novelty: incrementally updated iterative computation.
You haven't been able to use this in Materialize yet though, for various reasons not the least of which is that SQL's `WITH RECURSIVE` clause is a bit of a semantic mess.

The good news is that as of quite recently, Materialize has preliminary (behind the `--unsafe-mode` flag) support for a `WITH MUTUALLY RECURSIVE` clause. 
This clause differs from `WITH RECURSIVE` in some important ways, and I'll explain what those are and why I'm excited about them.

## Recursion in SQL

[SQL99](https://en.wikipedia.org/wiki/SQL:1999) introduced the very useful common table expressions (CTEs), and with them the `RECURSIVE` modifier that allowed *recursive* common table expressions.

A common table expression allows you to use the `WITH` clause to name some expressions and then use them multiple times in your query:
```sql
-- Form the triangles (a, b, c) in a graph.
WITH 
    egdes (a, b) AS (
        SELECT a, b 
        FROM something_complicated1
        WHERE something_complicated2
    ),
    path2 (a, b, c) AS (
        SELECT e1.a, e1.b, e2.b as c,
        FROM edges e1, edges e2
        WHERE e1.b = e2.a
    )
-- Produce triples (a, b, c) where edges(a, c) and path2(a, b, c) exist.
SELECT a, b, c
FROM two_hops, edges
WHERE two_hops.a = edges.a
  AND two_hops.c = edges.b
```
You can even use the bindings in subsequent expressions, as we did with `edges` in `path2`.

Excitingly, the SQL folks realized that something really neat happens if you allow a binding to refer to itself.
Hearts full of excitement (one imagines) they introduced the `RECURSIVE` modifier that allows this.
```sql
WITH RECURSIVE
    egdes (a, b) AS (
        SELECT a, b 
        FROM something_complicated1
        WHERE something_complicated2
    ),
    -- LOOK THIS IS RECURSIVE!!!
    reach (a, b) AS (
        SELECT * FROM edges
        UNION
        SELECT e1.a, e2.b 
        FROM edges e1, edges e2 
        WHERE e1.b = e2.a
    )
SELECT * FROM reach
```
This is the classic example of recursion that you see in languages like [Datalog](), and StackOverflow pages discussing `WITH RECURSIVE`, but relatively rarely in actual `WITH RECURSIVE` queries.

As it turns out, `WTIH RECURSIVE` has a bevy of limitations and mysterious semantics (four pages in the version of the standard I have).
I certainly cannot enumerate, or even understand the full list, and will defer to the likes of [@teggy]() to expound upon the issues.
The main one that I'll flag, a total mystery to me, is that (in PostgreSQL at least)
```sql
mcsherry=# WITH RECURSIVE t(n) AS (
    VALUES (1)
    UNION ALL
    (
        WITH t AS (SELECT * FROM t)
        SELECT t1.n + t2.n AS n
        FROM t AS t1, t AS t2
        WHERE t1.n < 256
    )
)
SELECT * FROM t;
  n  
-----
   1
   2
   4
   8
  16
  32
  64
 128
 256
(9 rows)

mcsherry=# 
```
This is an example of "non-linear recursion" (`t` is used twice in the recursive term), which is both defined and forbidden in the SQL standard. 
Except that the standard defined linear recursion to be a query that uses the recursive term only once, and seemed to forget that this was in the part of the standard (`WITH` clauses) used to rebind names.
So the above query should be accepted, and just has crazy-pants semantics.

## Recursion in Materialize

Materialize doesn't support SQL's `WITH RECURSIVE` and based on the complexity of the spec may never support it.
Instead, it supports what I (naively?) think is a simpler, and yet more expressive fragment.
I'm a bit worried that I don't understand thet rationale behind the complexity of `WITH RECURSIVE`, and I both expect and will be delighted to have holes poked in what Materialize does instead.

Materialize's `WITH MUTUALLY RECURSIVE` clause allows a sequence of bindings, each of which can referencee any other binding in their body, followed by a body that can also reference any binding.
The results of the clause are as if you started each binding from an empty collection, and repeatedly updated the definitions of each binding in sequence, iterating through all bindings until no changes remain, and then evaluated the body with these final bindings.
```sql
materialize => WITH MUTUALLY RECURSIVE 
    numbers (n int) AS (
        VALUES (1)
        UNION ALL
        WITH rebound AS (SELECT * FROM numbers)
        SELECT DISTINCT t1.n + t2.n
        FROM rebound AS t1, rebound AS t2
        WHERE t1.n < 256 AND t2.n < 256
    )
SELECT COUNT(*) FROM numbers;
 count
-------
    510
(1 row)

mateorialize => 
```
This produces what is in my opinion the expected fixed point of the query above: all values from 1 through 510 (I copied the strict inequality).
Rather than just the powers of two strictly less than 512.

There are a few differences from SQL's `WITH RECURSIVE`: 

1.  We had to specify the type of the column of `numbers`. 
    We require this to make the SQL type resolution substantially easier, and not involve a recursive fixed-point problem when coercable types are used.
2.  We had to add the constraint `t2.n <= 256`.
    The absence of this constraint from the SQL version, and its termination nonetheless, still blows my mind.
    Of course you have to bound this, otherwise we would continue increasing `numbers` through the contributions of `t2`.
3.  We had to type `MUTUALLY`. 
    We aren't implementing `WITH RECURSIVE` correctly, so we have to call it something else.
    MySQL has a flag you can set to step away from SQL's semantics, but this seems easier for us at the moment.

The main other difference is in the limitations.
Whereas SQL has some four pages of restrictions, Materialize has none. 
Put whatever query you want in the definition of a recursive thing.
Don't want to use a `UNION` or `UNION ALL`? Don't.
Don't want to use linear recursion? Me neither!
Want to put another `WITH MUTUALLY RECURSIVE` clause in definition of a binding? Go right ahead, you devious villain! (Materialize will currently error at you if we end up rendering that dataflow, but that is our issue to fix).

Materialize having no restrictions has the comic potential to be a massive dumpster fire once we learn the *very important reasons* why SQL introduced the constraints.
However, it seems the best way to elicit that information is with this sort of post.

## Is Recursion Really that Important?

Yes.

Maybe not to you, maybe not to people you work with, or whose work you follow, and that is fine.
But yes.

Recursion or iteration are fundamental to *programming* languages, and languages without them are hobbled in their expressive power.
Languages without either, or with only limited forms, prevent their users from applying the full force of computer science.

I spent a fair few years needling folks in the Big Data and Dabatases spaces, pitting my laptop against their large and powerful computers.
The secret (shhh!) was that I had access to more comupter science than they did. 
Differential dataflow could express algorithms that they could not (or did not).
Perhaps the systems could, with human effort, effect the same computation, but why use system or language that makes computer science hard?